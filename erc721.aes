contract ERC721 =
  record state = { 
                   totalSupply      : int,
        				   name             : string,
        				   symbol           : string,
                   owner            : address,
        				   ownedTokensCount : map(address, int),
        				   tokenOwner       : map(int, address),
        				   tokenApprovals   : map(int, address)
                 }

	//todo add to state _operatorApprovals
  //todo repalce {} with Map.empty
  public stateful function  init() = {
    totalSupply = 0,
  	name = "NFT",
  	symbol = "AE",
    owner = Call.caller,
  	ownedTokensCount = {},
  	tokenOwner = {},
  	tokenApprovals = {}}

  public function name() : string = state.name

  public function symbol() : string = state.symbol

  public function totalSupply() : int = state.totalSupply

  public function balanceOf(tokenOwner : address) : int = lookupByAddress(tokenOwner, state.ownedTokensCount, 0)

  public function ownerOf(tokenId : int) = lookupById(tokenId, state.tokenOwner, #0)

  public stateful function mint(tokenId : int, to : address) : bool = 
    onlyOwner(Call.caller)
    put(state{tokenOwner = state.tokenOwner{[tokenId] = to}})
    put(state{ownedTokensCount[to] = add(lookupByAddress(to, state.ownedTokensCount, 0), 1)})
    true

  public stateful function burn(tokenId : int) : bool = 
    onlyTokenOwner(Call.caller, tokenId) 
    put(state{tokenOwner = state.tokenOwner{[tokenId] = #0}})
    put(state{ownedTokensCount[Call.caller] = sub(lookupByAddress(Call.caller, state.ownedTokensCount, 0), 1)})
    true

  public stateful function approve(tokenId : int, to : address) : bool =
    onlyTokenOwner(Call.caller, tokenId)

    require(to != Call.caller, "asd")
    require(isApprovedForAll(), "asd")
    
    put(state{tokenApprovals = state.tokenApprovals{[tokenId] = to}})
    true

  public function getApproved(tokenId : int) = 
    lookupById(tokenId, state.tokenApprovals, #0)

  public stateful function transferFrom(from : address, to : address, tokenId : int) : bool =
    require((isApprovedOrOwner()), "asd")

    clearApproval(from, tokenId)
    clearApproval(to, tokenId)

    true

  // todo impl
  public function isApprovedForAll() : bool =
    true

  // // todo impl  
  // public function setApprovalForAll() : bool =
  //   true

//Helper functions
  private function lookupByAddress(k : address, m, v) =
  	switch(Map.lookup(k, m))
	    None    => v
	    Some(x) => x

  private function lookupById(k : int, m, v) =
  	switch(Map.lookup(k, m))
	    None    => v
	    Some(x) => x

  private function add(_a : int, _b : int) : int =
    let c : int = _a + _b
    require(c >= _a, "Error")
    c

  private function sub(_a : int, _b : int) : int =
    require(_b =< _a, "Error")
    _a - _b

  //todo use native abort!!
  private function abort(err) = abort(err)

  private function require(b : bool, err : string) =
    if(!b) 
      abort(err)

  private function onlyOwner(owner : address) =
    if(owner != state.owner) 
      abort("Only owner can mint!")

  private function onlyTokenOwner(owner : address, tokenId : int) =
    if(owner != lookupById(tokenId, state.tokenOwner, #0)) 
      abort("Only token owner can transfer!")

  private function isApprovedOrOwner(spender : address, tokenId : int) : bool = 
    let owner : address = ownerOf(tokenId)
    getApproved(tokenId) == spender || owner == spender || isApprovedForAll()

  private function clearApproval(from : address, tokenId : int) : bool = 
    put(state{tokenApprovals = state.tokenApprovals{[tokenId] = #0}})
    true

  // private function removeTokenFrom(from : address, tokenId : int) : bool = 
  //   put(state{tokenOwner = state.tokenOwner{[tokenId] = to}})
  //   put(state{ownedTokensCount[to] = add(lookupByAddress(to, state.ownedTokensCount, 0), 1)})

   
//Helper functions

// to be implemented
// function approve(address _to, uint256 _tokenId);
// function takeOwnership(uint256 _tokenId);
// function transfer(address _to, uint256 _tokenId);
// function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId);
// // Token metadata
// function tokenMetadata(uint256 _tokenId) constant returns (string infoUrl);