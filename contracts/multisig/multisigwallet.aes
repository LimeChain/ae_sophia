contract Voting =
    public function vote   : () => bool
    public function revoke : () => bool
    public function result : () => int

contract MultiSigWallet =
    record state = { 
        owner                    : address,
        configured               : bool, 
        ownersCount              : int,
        transactionsCount        : int,
        required                 : int,
        owners                   : map(int, address),
        transactions             : map(int, transaction),
        ownerIndex               : map(address, int),
        removeOwner              : map(address, int),
        addOwner                 : map(address, int),
        removeOwnerConfirmations : map(address, map(address, bool)),
        addOwnerConfirmations    : map(address, map(address, bool)),
        txConfirmations          : map(int, map(address, bool))}
    
    record transaction = { 
        id            : int,
        confirmations : int,
        method        : string}

    datatype method = 
        Vote   |  
        Revoke | 
        Result
          
    public stateful function init(required : int) = {
        required                 = required,
        owner                    = Call.caller,
        configured               = false,
        ownersCount              = 0,
        transactionsCount        = 0,
        owners                   = {},
        ownerIndex               = {},
        transactions             = {},
        removeOwner              = {},
        addOwner                 = {},
        txConfirmations          = {},
        addOwnerConfirmations    = {},
        removeOwnerConfirmations = {}}

    public function getConfirmations(txId : int) : int =
        onlyConfigured()

        state.transactions[txId].confirmations

    public stateful function executeTransaction(txId : int, v : Voting) : bool = 
        onlyOwners()
        onlyConfigured()
        validRequirement()

        let transaction : transaction = state.transactions[txId]
        require(transaction.confirmations == state.ownersCount, "")

        switch(transaction.method)
            "Vote"   => v.vote()
            "Revoke" => v.revoke()

        true

    public stateful function approve(txId : int) = 
        onlyOwners()
        onlyConfigured()
        require(state.txConfirmations[txId][Call.caller] == false, "")

        let transaction : transaction = state.transactions[txId]

        let transaction' = transaction { 
            id = transaction.id, 
            confirmations = transaction.confirmations + 1, 
            method = transaction.method }

        put(state{txConfirmations[txId][Call.caller] = true})
        put(state{transactions = state.transactions{[txId] = transaction'}})

    public stateful function addTransaction(method : string) : int = 
        onlyOwners()
        onlyConfigured()
        // validate method !?

        let tx : transaction = {
            id             = state.transactionsCount,
            confirmations  = 0,
            method         = method}

        put(state{transactions = state.transactions{[state.transactionsCount] = tx}})
        put(state{transactionsCount = state.transactionsCount + 1})  

        tx.id

    public stateful function addOwner(owner : address, incrementRequired : bool)  = 
        onlyOwners()
        onlyConfigured()
        require(state.addOwner[owner] == (state.required - 1), "Not enough votes to add new owner")
        require(state.addOwnerConfirmations[owner][Call.caller] == false, "")

        addNewOwner(owner)

        if(incrementRequired)
            put(state{required = state.required + 1})    

    public stateful function initOwner(owner : address) = 
        onlyOwner()
        onlyNotConfigured()

        addNewOwner(owner)

    public stateful function removeOwner(owner : address) =
        onlyOwners()
        onlyConfigured()
        require(state.required == (state.removeOwner[owner] - 1), "Not enough votes to remove owner")
        require(state.removeOwnerConfirmations[owner][Call.caller] == false, "")

        let ownerId = state.ownerIndex[owner]

        Map.delete(owner, state.removeOwner)
        Map.delete(owner, state.ownerIndex)
        Map.delete(ownerId, state.owners)
        put(state{ownersCount = state.ownersCount - 1})    
        put(state{required = state.required - 1})    

    public stateful function voteRemoveOwner(owner : address) =
        onlyOwners()
        onlyConfigured()
        require(state.removeOwnerConfirmations[owner][Call.caller] == false, "")
        
        put(state{removeOwner = state.removeOwner{[owner] = state.removeOwner[owner] + 1}})

    public stateful function voteAddOwner(owner : address) =
        onlyOwners()
        onlyConfigured()
        require(state.addOwnerConfirmations[owner][Call.caller] == false, "")
        
        put(state{addOwner = state.addOwner{[owner] = state.addOwner[owner] + 1}})

    public stateful function configure() = 
        onlyOwner()

        put(state{configured = true})

    private stateful function addNewOwner(owner : address) =
        require(owner != Contract.address, "Address can't be same as contract address")
           
        put(state{ownersCount = state.ownersCount + 1})    
        put(state{owners = state.owners{[state.ownersCount] = owner}})
        put(state{ownerIndex = state.ownerIndex{[owner] = state.ownersCount}}) 

    private function onlyOwner() =
        require(Call.caller == state.owner, "Only owner")
        
    private function onlyOwners() =
        require(lookupByAddress(Call.caller, state.ownerIndex, 0) != 0, "Only owners")

    private function lookupByAddress(k : address, m, v) =
        switch(Map.lookup(k, m))
            None    => v
            Some(x) => x

    private function lookupById(k : int, m, v) =
        switch(Map.lookup(k, m))
            None    => v
            Some(x) => x

    private function validRequirement() =
        require(state.ownersCount > 0, "Owners count should be greater than zero")
        require(state.ownersCount =< state.required, "Owners count can't be greater than required")
        require(state.required > 0, "Required should be greater than zeo")

    private function onlyNotConfigured() =
        require(state.configured == false, "Only not configured")

    private function onlyConfigured() =
        require(state.configured == true, "Only configured")

    private function require(b : bool, err : string) =
        if(!b) 
            abort(err)

    private function add(_a : int, _b : int) : int =
        let c : int = _a + _b
        require(c >= _a, "Error")
        c
    
    private function sub(_a : int, _b : int) : int =
        require(_b =< _a, "Error")
        _a - _b