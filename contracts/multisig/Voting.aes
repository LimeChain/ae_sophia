contract MultiSig =

    // record pending_state = { yetNeeded : int, ownersDone : int, index : int }

    // datatype event =
    //     Confirmation (address, hash)    // of { .owner : Address, .operation : Hash }
    //   | Revoke       (address, hash)    // of { .owner : Address, .operation : Hash }
    //   | OwnerChanged (address, address) // of { .oldOwner : Address, .newOwner : Address }
    //   | OwnerAdded   (address)          // of { .newOwner : Address }
    //   | OwnerRemoved (address)          // of { .removedOwner : Address }
    //   | ReqChanged   (uint)             // of { .newReq : uint }

    // let maxOwners : uint = 250
    record state = 
        { 
            owner        : address
            configured   : bool, 
            required     : int, 
            ownersCount  : int,
            owners       : map(int, address),
            ownerIndex   : map(address, int),
            pending      : map(int, pending_state),
            pendingIndex : list(address)
        }

    function init (required : int) : state = 
        {   owner            = Call.caller
            configured       = false,
            required         = required,
            ownersCount      = 0,
            owners           = {},
            ownerIndex       = {},
            pending          = {},
            pendingIndex     = []}
    

    function addOwner(owner : address) = 
        put(state{owners = state.owners{[state.ownersCount] = owner}})
        put(state{ownersCount = state.ownersCount + 1})
    
    private function onlyOwner(owner : address) =
        if(owner != state.owner) 
            abort("Only owner can mint!")
    
    // function revoke(operation : hash) =
    //   let ownerIx = lookup(state.ownerIndex, caller())
    //   let pending = lookup(state.pendingIndex, operation)
    //   let ownerIxBit = 1 bsl (ownerIx - 1)
    //   let _ = require(pending.ownersDone band ownerIxBit > 0)
    //   let pending' = pending { yetNeeded  = pending.yetNeeded + 1
    //                          , ownersDone = pending.ownersDone - ownerIxBit }
    //   put(state{ pendingIndex.operator = pending' })
    //   event(Revoke(caller, operation))


    // datatype check_pending = CheckOk(state) | CheckFail(state)

    // function changeOwner(fromOwner : address, toOwner : address) =
    //   switch(check_pending(callhash()))
    //     CheckFail(state') => { state = state' }
    //     CheckOk(state') =>
    //         if(isOwner(toOwner)) put(state')
    //         else
    //           switch(Map.get(fromOwner, state.ownerIndex))
    //             None => { state = state' }
    //             Some(ownerIx) =>
    //                 { state = state' { owners = Map.insert(ownerIx, toOwner, state'.owners)
    //                                 , ownerIndex = Map.delete(fromOwner, Map.insert(toOwner, ownerIx, state'.ownerIndex))
    //                                 , pending = Map.empty
    //                                 , pendingIx = [] },
    //                   events = [OwnerChanged(fromOwner, toOwner)] }

    // function addOwner(newOwner : address) =
    //   let _ = require (!isOwner(newOwner))
    //   switch(check_pending(callhash()))
    //     CheckFail(state') => { state = state' }
    //     CheckOk(state') =>
    //         if(state.nOwners >= maxOwners) () /* TODO */
    //         else
    //           let nOwners' = state'.nOwners + 1
    //           { state = state' { owners    = Map.insert(nOwners', newOwner, state'.owners)
    //                           , ownerIndex = Map.insert(newOwner, nOwners', state'.ownerIndex)
    //                           , pending    = Map.empty
    //                           , pendingIx  = [] },
    //             event = [OwnerAdded(newOwner)] }

    // function removeOwner(oldOwner : address) =
    //   let _ = require(isOwner(oldOwner))
    //   let _ = require(state.nRequired > state.nOwners - 1)
    //   switch(check_pending(callhash()))
    //     CheckFail(state') => { state = state' }
    //     CheckOk(state') =>
    //         let ownerIx = lookup(state'.ownerIndex, oldOwner)
    //         { state = state' { owners = Map.delete(ownerIx, state'.owners)
    //                          , ownerIndex = Map.delete(newOwner, state'.ownerIndex)
    //                          , pending = Map.empty
    //                          , pendingIx = [] },
    //           event = [OwnerRemoved(oldOwner)] }

    // function changeRequirement(newReq : uint) =
    //   let _ = require(newReq =< state.nOwners)
    //   switch(check_pending(callhash()))
    //     CheckFail(state') => { state = state' }
    //     CheckOk(state') =>
    //       { state = state' { nRequired = newReq
    //                        , pending = Map.empty
    //                        , pendingIx = [] },
    //         event = [ReqChanged(newReq)] }


    // function getOwner(ownerIx0 : uint) =
    //   lookup(state.owners, ownerIx0 + 1)

    // function isOwner(owner : address) =
    //   switch(Map.get(owner, state.ownerIndex))
    //     None    => false
    //     Some(_) => true

    // function hasConfirmed(operation : hash, owner : address) =
    //   switch(Map.get(operation, state.pending))
    //     None => false
    //     Some(pending) =>
    //       let _ = require(isOwner(owner))
    //       let ownerIx = lookup(state.ownerIndex, owner)
    //       let ownerIxBit = 1 bsl (ownerIx - 1)
    //       (pending.ownersDone band ownerIxBit) != 0

    /* Leave the rest for now... */