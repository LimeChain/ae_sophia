contract ERC20 =
  public function totalSupply : () => int
  public function balanceOf : address => int
  public function allowance : address, address => int
  public function transfer : address, int => bool
  public function approve : address, int => bool
  public function transferFrom : address, address, int => bool
  public function increaseAllowance : address, int => bool
  public function decreaseAllowance : address, int => bool
  public  function mint : address, int => bool
  public stateful function burn : int => bool


contract Crowdsale =

    record state = { 
        erc20token : ERC20,
        wallet : address, // Address where funds are collected
        rate : int, 
        weiRaised : int
        some_map          : map((int,address), bool)} // map(int, map(address, bool))

    public stateful function init(_erc20 : ERC20, _wallet : address, _rate : int) = 
    // require(rate > 0);
    // require(wallet != address(0));
    // require(token != address(0));
        { erc20token = _erc20,
          wallet = _wallet,
          rate = _rate,
          weiRaised = 0,
          some_map = {}}

    // the address where funds are collected.
    public function wallet() : address =
        wallet

    // the number of token units a buyer gets per wei.
    public function rate() : int =
        rate

    // the amount of wei raised.
    public function weiRaised() : int =
        weiRaised

    // beneficiary: Recipient of the token purchase
    public stateful function buyTokens(_beneficiary : address) =
        let weiAmount = Call.value

        _preValidatePurchase(_beneficiary, weiAmount)
        // calculate token amount to be created
        let tokens = _getTokenAmount(weiAmount)

        // update state
        put(state{weiRaised = add(state.weiRaised, weiAmount)})

        _processPurchase(_beneficiary, tokens)
        // emit TokensPurchased(msg.sender, _beneficiary, weiAmount, tokens);

        _updatePurchasingState(_beneficiary, weiAmount)

        _forwardFunds()
        _postValidatePurchase(_beneficiary, weiAmount)


    // Validation of an incoming purchase. Use require statements to revert state when conditions are not met.
    // _beneficiary Address performing the token purchase
    // _amount Value involved in the purchase
    private function _preValidatePurchase(address _beneficiary, int _amount) =
            require(_beneficiary != address(0), "Should not be empty address.");
            require(_amount != 0, "Value cannot be zero.")

    // Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.
    // _beneficiary Address performing the token purchase
    // _amount Value involved in the purchase
    private function _postValidatePurchase(address _beneficiary, int _amount) : bool =
        require(true, "")

    // Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.
    // _beneficiary Address performing the token purchase
    // _tokenAmount Number of tokens to be emitted
    private function _deliverTokens(address _beneficiary, int _tokenAmount) =
        state.erc20token.safeTransfer(_beneficiary, _tokenAmount)
    
    // Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send tokens.
    // _beneficiary Address receiving the tokens
    // _tokenAmount Number of tokens to be purchased
    private function _processPurchase(address _beneficiary, int _tokenAmount) =
        _deliverTokens(_beneficiary, _tokenAmount)

    // Override for extensions that require an internal state to check for validity (current user contributions, etc.)
    // _beneficiary Address receiving the tokens
    // _amount Value in wei involved in the purchase
    private function _updatePurchasingState(address _beneficiary, int _amount) =
        // optional override
        require(true, "")


    // Override to extend the way in which ether is converted to tokens.
    // _amount Value to be converted into tokens
    //  Number of tokens that can be purchased with the specified _weiAmount
    private function _getTokenAmount(int _amount) : int =
        mul(_amount, _rate)

    private function _forwardFunds() =
        //_wallet.transfer(msg.value)
        raw_spend(state.wallet, Call.value)


    private function require(expression : bool, error : string) =
        if(!expression) 
            abort(err)


    // safe math 
    private function add(int a, int b) : int =
        let c = a + b;
        require((b >= 0 && c >= a) || (b < 0 && c < a), "Invalid sum operation.");

        c

    private function sub(int a, int b) : int =
        let c = a - b
        require((b >= 0 && c <= a) || (b < 0 && c > a), "Invalid subtract operation.");

        c
    
    private function mul(int a, int b) : int =
        if (a == 0)
            0

        let c = a * b;
        require(c / a == b), "Invalid multiplication operation.";

        c

    private function div(int a, int b) : int =
        require(b > 0, "Cannot divide to 0.")
        let c = a / b

        c


    //event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);
    
    /**
     * @dev fallback function ***DO NOT OVERRIDE***
     * Note that other contracts will transfer fund with a base gas stipend
     * of 2300, which is not enough to call buyTokens. Consider calling
     * buyTokens directly when purchasing tokens from a contract.
     */
    // function () external payable {
    //     buyTokens(msg.sender);
    // }



